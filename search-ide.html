<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Redis IDE - Search Edition</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #1e1e1e;
            color: #d4d4d4;
            height: 100vh;
            overflow: hidden;
        }
        
        .ide-container {
            display: flex;
            height: 100vh;
        }
        
        /* Sidebar */
        .sidebar {
            width: 250px;
            background-color: #252526;
            border-right: 1px solid #3e3e42;
            display: flex;
            flex-direction: column;
        }
        
        .sidebar-header {
            padding: 15px;
            border-bottom: 1px solid #3e3e42;
        }
        
        .project-selector {
            width: 100%;
            padding: 8px;
            background-color: #3c3c3c;
            color: #cccccc;
            border: 1px solid #3e3e42;
            border-radius: 4px;
            margin-bottom: 10px;
        }
        
        .new-project-btn {
            width: 100%;
            padding: 8px;
            background-color: #0e639c;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
        }
        
        .new-project-btn:hover {
            background-color: #1177bb;
        }
        
        /* File Tree */
        .file-tree {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            min-height: 100px;
            position: relative;
        }
        
        .file-tree.drag-over {
            background-color: rgba(0, 122, 204, 0.1);
            outline: 2px dashed #007acc;
        }
        
        .tree-item {
            padding: 4px 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 4px;
            border-radius: 3px;
            font-size: 13px;
            user-select: none;
            transition: padding-left 0.2s ease;
        }
        
        .tree-item:hover {
            background-color: #2a2a2a;
        }
        
        .tree-item.selected {
            background-color: #094771;
        }
        
        .tree-item.folder.selected {
            background-color: #37373d;
        }
        
        .tree-item.drag-over {
            background-color: #007acc !important;
            outline: 2px solid #007acc;
        }
        
        .tree-item[draggable="true"] {
            cursor: move;
        }
        
        .folder-arrow {
            width: 12px;
            font-size: 10px;
            color: #cccccc;
            cursor: pointer;
            user-select: none;
            display: inline-block;
        }
        
        .folder-arrow:hover {
            color: #ffffff;
        }
        
        .tree-controls {
            padding: 10px;
            border-top: 1px solid #3e3e42;
            display: flex;
            gap: 5px;
            position: relative;
        }
        
        .tree-controls::before {
            content: attr(data-hint);
            display: block;
            position: absolute;
            top: -20px;
            left: 10px;
            right: 10px;
            padding: 5px 10px;
            font-size: 11px;
            color: #888;
            text-align: center;
        }
        
        .tree-controls button {
            flex: 1;
            padding: 6px;
            background-color: #3c3c3c;
            color: #cccccc;
            border: 1px solid #3e3e42;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .tree-controls button:hover {
            background-color: #484848;
        }
        
        /* Editor Area */
        .editor-area {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        .editor-tabs {
            background-color: #2d2d30;
            border-bottom: 1px solid #3e3e42;
            display: flex;
            height: 35px;
            overflow-x: auto;
        }
        
        .tab {
            padding: 0 20px;
            background-color: #2d2d30;
            border-right: 1px solid #3e3e42;
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            font-size: 13px;
            white-space: nowrap;
            min-width: 120px;
        }
        
        .tab:hover {
            background-color: #353537;
        }
        
        .tab.active {
            background-color: #1e1e1e;
        }
        
        .tab-close {
            margin-left: auto;
            font-size: 16px;
            color: #888;
            cursor: pointer;
            padding: 0 5px;
        }
        
        .tab-close:hover {
            color: #fff;
        }
        
        .tab.dirty::after {
            content: '•';
            color: #fff;
            margin-left: 5px;
            font-size: 20px;
            line-height: 0;
        }
        
        #monaco-container {
            flex: 1;
            position: relative;
        }
        
        /* Status Bar */
        .status-bar {
            height: 22px;
            background-color: #007acc;
            color: white;
            display: flex;
            align-items: center;
            padding: 0 10px;
            font-size: 12px;
        }
        
        .status-message {
            margin-right: auto;
        }
        
        .status-right {
            display: flex;
            gap: 20px;
            align-items: center;
        }
        
        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1000;
        }
        
        .modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #2d2d30;
            padding: 20px;
            border-radius: 6px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            min-width: 400px;
        }
        
        .modal-header {
            margin-bottom: 15px;
            font-size: 16px;
            font-weight: 500;
        }
        
        .modal input {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            background-color: #3c3c3c;
            color: #cccccc;
            border: 1px solid #3e3e42;
            border-radius: 4px;
        }
        
        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }
        
        .modal button {
            padding: 6px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
        }
        
        .modal .primary {
            background-color: #0e639c;
            color: white;
        }
        
        .modal .secondary {
            background-color: #3c3c3c;
            color: #cccccc;
            border: 1px solid #3e3e42;
        }
        
        /* Loading indicator */
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #888;
            font-size: 14px;
        }
        
        /* Context Menu */
        .context-menu {
            display: none;
            position: fixed;
            background-color: #252526;
            border: 1px solid #3e3e42;
            border-radius: 4px;
            padding: 4px 0;
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            min-width: 150px;
        }
        
        .context-menu-item {
            padding: 6px 20px;
            cursor: pointer;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .context-menu-item:hover {
            background-color: #094771;
        }
        
        .context-menu-separator {
            height: 1px;
            background-color: #3e3e42;
            margin: 4px 0;
        }
        
        /* Undo notification */
        .undo-notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: #323233;
            color: #fff;
            padding: 12px 20px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 15px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            animation: slideIn 0.3s ease;
        }
        
        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        .undo-button {
            background-color: #0e639c;
            color: white;
            border: none;
            padding: 4px 12px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .undo-button:hover {
            background-color: #1177bb;
        }
        /* Search Box */
        .search-container {
            padding: 10px;
            border-bottom: 1px solid #3e3e42;
        }
        
        .search-box {
            position: relative;
            display: flex;
            align-items: center;
        }
        
        .search-input {
            width: 100%;
            padding: 6px 30px 6px 8px;
            background-color: #3c3c3c;
            color: #cccccc;
            border: 1px solid #3e3e42;
            border-radius: 4px;
            font-size: 13px;
        }
        
        .search-icon {
            position: absolute;
            right: 8px;
            color: #888;
            cursor: pointer;
        }
        
        .search-filters {
            margin-top: 8px;
            font-size: 12px;
        }
        
        .search-filters label {
            margin-right: 10px;
            cursor: pointer;
        }
        
        .search-filters input[type="checkbox"] {
            margin-right: 4px;
        }
        
        /* Search Results Panel */
        .search-results-panel {
            display: none;
            height: 200px;
            background-color: #252526;
            border-bottom: 1px solid #3e3e42;
            overflow-y: auto;
            resize: vertical;
        }
        
        .search-results-header {
            padding: 8px 15px;
            background-color: #2d2d30;
            border-bottom: 1px solid #3e3e42;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 13px;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        
        .search-result-item {
            padding: 8px 15px;
            border-bottom: 1px solid #3e3e42;
            cursor: pointer;
        }
        
        .search-result-item:hover {
            background-color: #2a2a2a;
        }
        
        .search-result-file {
            color: #4ec9b0;
            font-size: 12px;
            margin-bottom: 4px;
        }
        
        .search-result-content {
            font-size: 12px;
            color: #cccccc;
            white-space: pre-wrap;
            font-family: 'Consolas', 'Monaco', monospace;
            line-height: 1.4;
        }
        
        .search-result-content mark {
            background-color: #515c6a;
            color: #ffffff;
            font-weight: bold;
            border-radius: 2px;
            padding: 0 2px;
        }
        
        /* Search status in status bar */
        .search-status {
            margin-right: 20px;
            color: #cccccc;
        }
        
        /* Make editor area flex to accommodate search panel */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        .editor-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }
    </style>
</head>
<body>
    <div class="ide-container">
        <!-- Sidebar -->
        <div class="sidebar">
            <div class="sidebar-header">
                <select id="projectSelector" class="project-selector">
                    <option value="">Select a project...</option>
                </select>
                <button class="new-project-btn" onclick="showNewProjectModal()">+ New Project</button>
            </div>
            
            <!-- Search Box -->
            <div class="search-container">
                <div class="search-box">
                    <input type="text" 
                           id="searchInput" 
                           class="search-input" 
                           placeholder="Search in project... (Ctrl+Shift+F)"
                           onkeypress="handleSearchKeypress(event)">
                    <span class="search-icon" onclick="performSearch()">🔍</span>
                </div>
                <div class="search-filters">
                    <label>
                        <input type="checkbox" id="searchCurrentProject" checked>
                        Current project only
                    </label>
                </div>
            </div>
            
            <div class="file-tree" id="fileTree">
                <div style="padding: 20px; text-align: center; color: #888;">
                    Select or create a project
                </div>
            </div>
            
            <div class="tree-controls" id="treeControls" data-hint="📁 root">
                <button onclick="showNewFileModal()">📄 New File</button>
                <button onclick="showNewFolderModal()">📁 New Folder</button>
            </div>
        </div>
        
        <!-- Main Content Area -->
        <div class="main-content">
            <!-- Search Results Panel -->
            <div id="searchResultsPanel" class="search-results-panel">
                <div class="search-results-header">
                    <span id="searchResultsCount">0 results</span>
                    <span style="cursor: pointer;" onclick="closeSearchResults()">✕</span>
                </div>
                <div id="searchResultsList"></div>
            </div>
            
            <!-- Editor Area -->
            <div class="editor-area">
                <div class="editor-tabs" id="editorTabs">
                    <!-- Tabs will be added dynamically -->
                </div>
                
                <div id="monaco-container">
                    <div class="loading" id="loading">Loading Monaco Editor...</div>
                </div>
                
                <div class="status-bar">
                    <span class="status-message" id="statusMessage">Ready</span>
                    <span class="search-status" id="searchStatus"></span>
                    <div class="status-right">
                        <span id="cursorPosition">Ln 1, Col 1</span>
                        <span id="languageMode">JavaScript</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Copy ALL modals and context menu from monaco-ide.html -->
    <!-- Context Menu -->
    <div id="contextMenu" class="context-menu">
        <div class="context-menu-item" onclick="startInlineRename()">
            <span>✏️</span>
            <span>Rename (F2)</span>
        </div>
        <div class="context-menu-item" onclick="deleteItem()">
            <span>🗑️</span>
            <span>Delete</span>
        </div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" onclick="newFileInFolder()">
            <span>📄</span>
            <span>New File</span>
        </div>
        <div class="context-menu-item" onclick="newFolderInFolder()">
            <span>📁</span>
            <span>New Folder</span>
        </div>
    </div>
    
    <!-- Modals -->
    <div id="newProjectModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">Create New Project</div>
            <input type="text" id="newProjectName" placeholder="Project name">
            <input type="text" id="newProjectDescription" placeholder="Description (optional)">
            <div class="modal-buttons">
                <button class="secondary" onclick="closeModal('newProjectModal')">Cancel</button>
                <button class="primary" onclick="createProject()">Create</button>
            </div>
        </div>
    </div>
    
    <div id="newFileModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">Create New File</div>
            <input type="text" id="newFilePath" placeholder="File path (e.g., src/index.js)">
            <div class="modal-buttons">
                <button class="secondary" onclick="closeModal('newFileModal')">Cancel</button>
                <button class="primary" onclick="createFile()">Create</button>
            </div>
        </div>
    </div>
    
    <div id="newFolderModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">Create New Folder</div>
            <input type="text" id="newFolderPath" placeholder="Folder path (e.g., src/components)">
            <div class="modal-buttons">
                <button class="secondary" onclick="closeModal('newFolderModal')">Cancel</button>
                <button class="primary" onclick="createFolder()">Create</button>
            </div>
        </div>
    </div>
    <!-- Load dependencies -->
    <script src="https://unpkg.com/monaco-editor@0.45.0/min/vs/loader.js"></script>
    
    <script>
        const API_URL = 'http://localhost:3000/api';
        let currentProject = null;
        let openFiles = new Map(); // filepath -> {content, model, viewState, dirty}
        let currentFile = null;
        let editor = null;
        let monaco = null;
        let currentFolder = null;
        let expandedFolders = new Set();
        let isRenaming = false;
        let renameTimeout = null;
        let contextMenuTarget = null;
        let contextMenuType = null;
        let lastContextElement = null;
        let draggedItem = null;
        let draggedItemPath = null;
        let draggedItemType = null;
        let undoTimeout = null;
        let searchResults = [];

        // Configure Monaco loader
        require.config({ 
            paths: { 
                'vs': 'https://unpkg.com/monaco-editor@0.45.0/min/vs' 
            }
        });

        // Initialize Monaco and the app
        require(['vs/editor/editor.main'], function() {
            monaco = window.monaco;
            initializeEditor();
            initializeApp();
        });

        // Initialize Monaco Editor
        function initializeEditor() {
            document.getElementById('loading').style.display = 'none';
            
            // Define custom theme
            monaco.editor.defineTheme('redis-dark', {
                base: 'vs-dark',
                inherit: true,
                rules: [
                    { token: 'comment', foreground: '608B4E' },
                    { token: 'keyword', foreground: '569CD6' },
                    { token: 'string', foreground: 'CE9178' }
                ],
                colors: {
                    'editor.background': '#1E1E1E',
                    'editor.foreground': '#D4D4D4',
                    'editor.lineHighlightBackground': '#2D2D30',
                    'editorCursor.foreground': '#AEAFAD',
                    'editor.selectionBackground': '#264F78'
                }
            });
            
            // Create editor
            editor = monaco.editor.create(document.getElementById('monaco-container'), {
                value: '// Welcome to Redis IDE with Monaco Editor\n// Select or create a project to start coding!',
                language: 'javascript',
                theme: 'redis-dark',
                automaticLayout: true,
                fontSize: 14,
                minimap: {
                    enabled: true
                },
                scrollBeyondLastLine: false,
                wordWrap: 'on',
                formatOnPaste: true,
                formatOnType: true,
                suggestOnTriggerCharacters: true,
                quickSuggestions: {
                    other: true,
                    comments: true,
                    strings: true
                },
                parameterHints: {
                    enabled: true
                },
                tabSize: 2,
                insertSpaces: true
            });

            // Handle editor changes
            editor.onDidChangeModelContent(() => {
                if (currentFile && openFiles.has(currentFile)) {
                    const fileData = openFiles.get(currentFile);
                    fileData.content = editor.getValue();
                    fileData.dirty = true;
                    openFiles.set(currentFile, fileData);
                    updateTabs();
                    updateStatus('Modified');
                    
                    // Auto-save after 1 second of inactivity
                    clearTimeout(window.saveTimeout);
                    window.saveTimeout = setTimeout(() => {
                        saveCurrentFile();
                    }, 1000);
                }
            });

            // Update cursor position
            editor.onDidChangeCursorPosition((e) => {
                const position = e.position;
                document.getElementById('cursorPosition').textContent = 
                    `Ln ${position.lineNumber}, Col ${position.column}`;
            });

            // Set up keyboard shortcuts
            editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyS, () => {
                saveCurrentFile();
            });

            editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyW, () => {
                if (currentFile) {
                    closeFile(currentFile);
                }
            });

            // Format document shortcut
            editor.addCommand(monaco.KeyMod.Alt | monaco.KeyMod.Shift | monaco.KeyCode.KeyF, () => {
                editor.getAction('editor.action.formatDocument').run();
            });
        }

        // Initialize app
        async function initializeApp() {
            await loadProjects();
            setupEventListeners();
            setupKeyboardShortcuts();
            updateTreeControlsHint();
            createProjectDropdown();
        }

        // Add find/replace support
        editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyF, () => {
                editor.getAction('actions.find').run();
            });
            
            editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyH, () => {
                editor.getAction('editor.action.startFindReplaceAction').run();
            });
        
        // Open file with Monaco
        async function openFile(filepath) {
            if (!currentProject) return;
            
            // Check if file is already open
            if (openFiles.has(filepath)) {
                switchToFile(filepath);
                return;
            }
            
            try {
                const response = await fetch(`${API_URL}/projects/${currentProject.id}/files/${encodeURIComponent(filepath)}`);
                const data = await response.json();
                
                // Create Monaco model for the file
                const language = getLanguageMode(filepath);
                const model = monaco.editor.createModel(data.content, language);
                
                // Store file data
                openFiles.set(filepath, {
                    content: data.content,
                    model: model,
                    viewState: null,
                    dirty: false
                });
                
                switchToFile(filepath);
                updateStatus(`Opened: ${filepath}`);
            } catch (error) {
                console.error('Error opening file:', error);
                updateStatus('Error opening file', true);
            }
        }

        // Switch to an already open file
        function switchToFile(filepath) {
            const fileData = openFiles.get(filepath);
            if (!fileData) return;
            
            // Save current view state
            if (currentFile && openFiles.has(currentFile)) {
                const currentData = openFiles.get(currentFile);
                currentData.viewState = editor.saveViewState();
            }
            
            // Switch to new file
            currentFile = filepath;
            editor.setModel(fileData.model);
            
            // Restore view state if available
            if (fileData.viewState) {
                editor.restoreViewState(fileData.viewState);
            }
            
            // Update UI
            updateTabs();
            updateFileTree();
            
            // Update language mode display
            const language = getLanguageMode(filepath);
            document.getElementById('languageMode').textContent = 
                language.charAt(0).toUpperCase() + language.slice(1);
        }

        // Save current file
        async function saveCurrentFile() {
            if (!currentFile || !currentProject) return;
            
            const fileData = openFiles.get(currentFile);
            if (!fileData || !fileData.dirty) return;
            
            try {
                const content = fileData.content;
                const response = await fetch(
                    `${API_URL}/projects/${currentProject.id}/files/${encodeURIComponent(currentFile)}`, 
                    {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ content })
                    }
                );
                
                if (response.ok) {
                    fileData.dirty = false;
                    updateTabs();
                    updateStatus(`Saved: ${currentFile}`);
                }
            } catch (error) {
                console.error('Error saving file:', error);
                updateStatus('Error saving file', true);
            }
        }

        // Update editor tabs
        function updateTabs() {
            const tabsContainer = document.getElementById('editorTabs');
            tabsContainer.innerHTML = '';
            
            openFiles.forEach((fileData, filepath) => {
                const filename = filepath.split('/').pop();
                const tab = document.createElement('div');
                tab.className = `tab ${filepath === currentFile ? 'active' : ''} ${fileData.dirty ? 'dirty' : ''}`;
                
                const nameSpan = document.createElement('span');
                nameSpan.textContent = filename;
                nameSpan.onclick = () => switchToFile(filepath);
                
                const closeSpan = document.createElement('span');
                closeSpan.className = 'tab-close';
                closeSpan.textContent = '×';
                closeSpan.onclick = (e) => {
                    e.stopPropagation();
                    closeFile(filepath);
                };
                
                tab.appendChild(nameSpan);
                tab.appendChild(closeSpan);
                tabsContainer.appendChild(tab);
            });
        }

        // Close file
        function closeFile(filepath) {
            const fileData = openFiles.get(filepath);
            
            if (fileData && fileData.dirty) {
                if (!confirm(`Save changes to ${filepath.split('/').pop()} before closing?`)) {
                    // Don't save
                } else {
                    // Save before closing
                    saveCurrentFile();
                }
            }
            
            // Dispose of the model
            if (fileData && fileData.model) {
                fileData.model.dispose();
            }
            
            openFiles.delete(filepath);
            
            if (filepath === currentFile) {
                // Switch to another open file or clear editor
                const remainingFiles = Array.from(openFiles.keys());
                if (remainingFiles.length > 0) {
                    switchToFile(remainingFiles[remainingFiles.length - 1]);
                } else {
                    currentFile = null;
                    editor.setModel(null);
                    editor.setValue('// No files open');
                }
            }
            
            updateTabs();
        }

        // Add all the other functions from Checkpoint 2
        // Just copy and paste all the working functions here
        // Replace the showUndoNotification function
        function showUndoNotification(itemName, itemType, restoreFunction) {
            // Clear any existing notification
            const existing = document.querySelector('.undo-notification');
            if (existing) existing.remove();
            
            // Clear any existing timeout
            if (undoTimeout) {
                clearTimeout(undoTimeout);
            }
            
            const notification = document.createElement('div');
            notification.className = 'undo-notification';
            notification.innerHTML = `
                <span>Deleted ${itemType} "${itemName}"</span>
                <button class="undo-button">Undo</button>
            `;
            
            document.body.appendChild(notification);
            
            // Add click handler directly to the button
            const undoButton = notification.querySelector('.undo-button');
            undoButton.addEventListener('click', async () => {
                try {
                    await restoreFunction();
                    notification.remove();
                    if (undoTimeout) {
                        clearTimeout(undoTimeout);
                    }
                } catch (error) {
                    console.error('Error undoing delete:', error);
                    updateStatus('Failed to undo deletion', true);
                }
            });
            
            // Auto-remove after 5 seconds
            undoTimeout = setTimeout(() => {
                notification.remove();
            }, 5000);
        }

        // Undo delete function
        async function undoDelete() {
            if (window.currentUndo) {
                await window.currentUndo();
                document.querySelector('.undo-notification')?.remove();
                window.currentUndo = null;
            }
        }

        function enableInlineRename(element, currentPath, type) {
            if (isRenaming) return;
            
            isRenaming = true;
            const originalName = currentPath.split('/').pop();
            const basePath = currentPath.substring(0, currentPath.lastIndexOf('/'));
            
            // Create input element
            const input = document.createElement('input');
            input.type = 'text';
            input.value = originalName;
            input.style.cssText = `
                background: #3c3c3c;
                border: 1px solid #007acc;
                color: #cccccc;
                padding: 2px 5px;
                font-size: 13px;
                font-family: inherit;
                width: 150px;
            `;
            
            // Replace the span with input
            const nameSpan = element.querySelector('span:last-child');
            const originalContent = nameSpan.textContent;
            nameSpan.textContent = '';
            nameSpan.appendChild(input);
            
            input.focus();
            input.select();
            
            // Handle save
            const saveRename = async () => {
                const newName = input.value.trim();
                
                if (newName && newName !== originalName) {
                    const newPath = basePath ? basePath + '/' + newName : newName;
                    
                    try {
                        const response = await fetch(`${API_URL}/projects/${currentProject.id}/rename`, {
                            method: 'PUT',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ 
                                oldPath: currentPath, 
                                newPath: newPath, 
                                isFolder: type === 'folder' 
                            })
                        });
                        
                        if (response.ok) {
                            updateStatus(`Renamed to ${newName}`);
                            await loadProjectFiles();
                            
                            // Update open files if needed
                            if (type === 'file' && openFiles.has(currentPath)) {
                                const content = openFiles.get(currentPath);
                                openFiles.delete(currentPath);
                                openFiles.set(newPath, content);
                                if (currentFile === currentPath) {
                                    currentFile = newPath;
                                    updateTabs();
                                }
                            }
                        }
                    } catch (error) {
                        console.error('Error renaming:', error);
                        updateStatus('Error renaming', true);
                    }
                }
                
                nameSpan.textContent = originalContent;
                isRenaming = false;
            };
            
            // Handle cancel
            const cancelRename = () => {
                nameSpan.textContent = originalContent;
                isRenaming = false;
            };
            
            input.addEventListener('blur', saveRename);
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    saveRename();
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    cancelRename();
                }
            });
        }

        // Update your setupKeyboardShortcuts function with better debugging
        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', async (e) => {
                // Log all keypresses for debugging
                if (e.key === 'F2' || e.key === 'Delete') {
                    console.log('Key pressed:', e.key);
                    console.log('contextMenuTarget:', contextMenuTarget);
                    console.log('lastContextElement:', window.lastContextElement);
                }
                
                // F2 for rename
                if (e.key === 'F2') {
                    e.preventDefault();
                    if (contextMenuTarget) {
                        // Find the element by data-path attribute
                        const element = document.querySelector(`[data-path="${contextMenuTarget}"]`);
                        if (element) {
                            window.lastContextElement = element;
                            startInlineRename();
                        } else {
                            console.log('Could not find element for path:', contextMenuTarget);
                        }
                    } else {
                        console.log('No file/folder selected. Right-click to select first.');
                    }
                }
                
                // Delete key
                if (e.key === 'Delete') {
                    e.preventDefault();
                    if (contextMenuTarget) {
                        await smartDelete();
                    } else {
                        console.log('No file/folder selected. Right-click to select first.');
                    }
                }
            });
            document.addEventListener('keydown', (e) => {
                // Ctrl+Shift+F for global search
                if (e.ctrlKey && e.shiftKey && e.key === 'F') {
                    e.preventDefault();
                    document.getElementById('searchInput').focus();
                }
            });
        }
        
        // Search functionality
        function handleSearchKeypress(event) {
            if (event.key === 'Enter') {
                performSearch();
            }
        }

        async function performSearch() {
            const query = document.getElementById('searchInput').value.trim();
            if (!query) return;
            
            const searchCurrentProject = document.getElementById('searchCurrentProject').checked;
            
            updateStatus('Searching...');
            document.getElementById('searchStatus').textContent = '🔍 Searching...';
            
            try {
                const url = searchCurrentProject && currentProject
                    ? `${API_URL}/projects/${currentProject.id}/search`
                    : `${API_URL}/search`;
                
                const response = await fetch(`${url}?q=${encodeURIComponent(query)}`);
                const results = await response.json();
                
                searchResults = results.documents || [];
                displaySearchResults(results);
                
                const statusText = results.fallback 
                    ? `Found ${results.total} results (fallback search)`
                    : `Found ${results.total} results`;
                
                updateStatus(statusText);
                document.getElementById('searchStatus').textContent = '';
                
            } catch (error) {
                console.error('Search error:', error);
                updateStatus('Search failed', true);
                document.getElementById('searchStatus').textContent = '';
            }
        }
        
        function displaySearchResults(results) {
            const panel = document.getElementById('searchResultsPanel');
            const list = document.getElementById('searchResultsList');
            const count = document.getElementById('searchResultsCount');
            
            if (results.total === 0) {
                list.innerHTML = '<div style="padding: 20px; text-align: center; color: #888;">No results found</div>';
            } else {
                list.innerHTML = results.documents.map((doc, index) => `
                    <div class="search-result-item" onclick="openSearchResult(${index})">
                        <div class="search-result-file">${doc.filepath}</div>
                        <div class="search-result-content">${doc.content || doc.snippet || ''}</div>
                    </div>
                `).join('');
            }
            
            count.textContent = `${results.total} result${results.total !== 1 ? 's' : ''} for "${results.query}"`;
            panel.style.display = 'block';
        }
        
        function closeSearchResults() {
            document.getElementById('searchResultsPanel').style.display = 'none';
        }
        
        async function openSearchResult(index) {
            const result = searchResults[index];
            if (!result) return;
            
            // Extract project ID from the result
            const projectId = result.projectId || result.key.split(':')[1];
            
            // If it's from a different project, load that project first
            if (projectId !== currentProject?.id) {
                await loadProject(projectId);
            }
            
            // Open the file
            await openFile(result.filepath);
            
            // Try to jump to the search term in the file
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm && editor) {
                const model = editor.getModel();
                const matches = model.findMatches(searchTerm, true, false, false, null, true);
                
                if (matches.length > 0) {
                    editor.setSelection(matches[0].range);
                    editor.revealRangeInCenter(matches[0].range);
                }
            }
        }

        // Also update smartDelete to use the same undo functionality
        async function smartDelete() {
            // Just call deleteItem since they should have the same behavior
            await deleteItem();
        }

        // 4. Project Management in Dropdown
        function createProjectDropdown() {
            const selector = document.getElementById('projectSelector');
            
            // Add event listener for right-click on options
            selector.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                if (e.target.tagName === 'OPTION' && e.target.value) {
                    showProjectContextMenu(e, e.target.value, e.target.textContent);
                }
            });
        }

        function showProjectContextMenu(event, projectId, projectName) {
            const menu = document.createElement('div');
            menu.className = 'context-menu';
            menu.style.cssText = `
                display: block;
                left: ${event.pageX}px;
                top: ${event.pageY}px;
            `;
            
            menu.innerHTML = `
                <div class="context-menu-item" onclick="renameProjectPrompt('${projectId}', '${projectName}')">
                    <span class="icon">✏️</span>
                    <span>Rename Project</span>
                </div>
                <div class="context-menu-item" onclick="deleteProjectPrompt('${projectId}', '${projectName}')">
                    <span class="icon">🗑️</span>
                    <span>Delete Project</span>
                </div>
            `;
            
            document.body.appendChild(menu);
            
            // Remove on click outside
            setTimeout(() => {
                document.addEventListener('click', () => menu.remove(), { once: true });
            }, 0);
        }

        async function renameProjectPrompt(projectId, oldName) {
            const newName = prompt('New project name:', oldName);
            if (!newName || newName === oldName) return;
            
            try {
                const response = await fetch(`${API_URL}/projects/${projectId}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name: newName })
                });
                
                if (response.ok) {
                    updateStatus(`Project renamed to ${newName}`);
                    await loadProjects();
                    if (currentProject && currentProject.id === projectId) {
                        currentProject.name = newName;
                    }
                }
            } catch (error) {
                console.error('Error renaming project:', error);
                updateStatus('Error renaming project', true);
            }
        }

        async function deleteProjectPrompt(projectId, projectName) {
            if (!confirm(`Delete project "${projectName}" and ALL its files? This cannot be undone.`)) return;
            
            try {
                const response = await fetch(`${API_URL}/projects/${projectId}`, {
                    method: 'DELETE'
                });
                
                if (response.ok) {
                    updateStatus(`Project ${projectName} deleted`);
                    if (currentProject && currentProject.id === projectId) {
                        currentProject = null;
                        openFiles.clear();
                        currentFile = null;
                        document.getElementById('fileTree').innerHTML = '<div style="padding: 20px; text-align: center; color: #888;">Select a project</div>';
                        document.getElementById('editor').value = '';
                        updateTabs();
                    }
                    await loadProjects();
                }
            } catch (error) {
                console.error('Error deleting project:', error);
                updateStatus('Error deleting project', true);
            }
        }

        // Setup event listeners
        function setupEventListeners() {
            // Click outside context menu to close
            document.addEventListener('click', () => {
                document.getElementById('contextMenu').style.display = 'none';
            });
            
            // File tree click handler for deselection
            document.getElementById('fileTree').addEventListener('click', (e) => {
                if (e.target.id === 'fileTree' || e.target.classList.contains('empty-message')) {
                    currentFolder = null;
                    document.querySelectorAll('.tree-item.folder').forEach(item => {
                        item.classList.remove('selected');
                    });
                    updateTreeControlsHint();
                    updateStatus('No folder selected');
                }
            });
            
            // File tree drag handlers
            const fileTree = document.getElementById('fileTree');
            fileTree.addEventListener('dragover', handleDragOver);
            fileTree.addEventListener('drop', (e) => {
                if (e.target === fileTree || e.target.classList.contains('empty-message')) {
                    handleDrop(e, '', 'root');
                }
            });
            fileTree.addEventListener('dragenter', (e) => {
                if (e.target === e.currentTarget) {
                    e.currentTarget.classList.add('drag-over');
                }
            });
            fileTree.addEventListener('dragleave', (e) => {
                if (e.target === e.currentTarget) {
                    e.currentTarget.classList.remove('drag-over');
                }
            });
            
            // Modal Enter key handlers
            document.querySelectorAll('.modal input').forEach(input => {
                input.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        const modal = input.closest('.modal');
                        const primaryButton = modal.querySelector('.primary');
                        primaryButton.click();
                    }
                });
            });
            
            // Click outside modal to close
            document.querySelectorAll('.modal').forEach(modal => {
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        modal.style.display = 'none';
                    }
                });
            });
        }

        // Load projects
        async function loadProjects() {
            try {
                const response = await fetch(`${API_URL}/projects`);
                const data = await response.json();
                
                const selector = document.getElementById('projectSelector');
                selector.innerHTML = '<option value="">Select a project...</option>';
                
                data.projects.forEach(project => {
                    const option = document.createElement('option');
                    option.value = project.id;
                    option.textContent = project.name;
                    selector.appendChild(option);
                });
                
                selector.onchange = () => {
                    if (selector.value) {
                        loadProject(selector.value);
                    }
                };
            } catch (error) {
                console.error('Error loading projects:', error);
                updateStatus('Error loading projects', true);
            }
        }

        // Load project
        async function loadProject(projectId) {
            try {
                // Clear state when switching projects
                openFiles.clear();
                currentFile = null;
                currentFolder = null;
                expandedFolders.clear();
                updateTabs();
                
                const response = await fetch(`${API_URL}/projects/${projectId}`);
                const data = await response.json();
                
                currentProject = data.project;
                
                // Auto-expand root level folders
                if (currentProject.files) {
                    Object.keys(currentProject.files).forEach(key => {
                        if (currentProject.files[key].type === 'folder' || currentProject.files[key].children) {
                            expandedFolders.add(key);
                        }
                    });
                }
                
                await loadProjectFiles();
                updateStatus(`Loaded project: ${currentProject.name}`);
            } catch (error) {
                console.error('Error loading project:', error);
                updateStatus('Error loading project', true);
            }
        }

        // Load project files
        async function loadProjectFiles() {
            if (!currentProject) return;
            
            try {
                // Get the complete project data including folder structure
                const projectResponse = await fetch(`${API_URL}/projects/${currentProject.id}`);
                const projectData = await projectResponse.json();
                
                const fileTree = document.getElementById('fileTree');
                
                if (projectData.project && projectData.project.files) {
                    const treeHtml = renderTreeNodes(projectData.project.files, 0);
                    fileTree.innerHTML = treeHtml || '<div style="padding: 20px; text-align: center; color: #888;">Empty project. Create files or folders!</div>';
                } else {
                    fileTree.innerHTML = '<div style="padding: 20px; text-align: center; color: #888;">No files yet. Create your first file!</div>';
                }
            } catch (error) {
                console.error('Error loading project files:', error);
            }
        }

        // Render tree nodes recursively
        function renderTreeNodes(nodes, level, parentPath = '') {
            let html = '';
            
            if (!nodes || Object.keys(nodes).length === 0) {
                return '';
            }
            
            Object.entries(nodes).sort(([a, nodeA], [b, nodeB]) => {
                const aIsFolder = nodeA.type === 'folder' || nodeA.children !== undefined;
                const bIsFolder = nodeB.type === 'folder' || nodeB.children !== undefined;
                if (aIsFolder && !bIsFolder) return -1;
                if (!aIsFolder && bIsFolder) return 1;
                return a.localeCompare(b);
            }).forEach(([name, node]) => {
                const indent = level * 20;
                const currentPath = parentPath ? `${parentPath}/${name}` : name;
                
                if (node.type === 'folder' || node.children !== undefined) {
                    const hasChildren = node.children && Object.keys(node.children).length > 0;
                    const isExpanded = expandedFolders.has(currentPath);
                    const isSelected = currentFolder === currentPath ? 'selected' : '';
                    
                    html += `
                        <div class="tree-item folder ${isSelected}" 
                             data-path="${currentPath}"
                             data-type="folder"
                             style="padding-left: ${indent}px"
                             onclick="selectFolder('${currentPath}', event)"
                             ondblclick="handleDoubleClick(event, '${currentPath}', 'folder')"
                             oncontextmenu="showContextMenu(event, '${currentPath}', 'folder')"
                             draggable="true"
                             ondragstart="handleDragStart(event, '${currentPath}', 'folder')"
                             ondragend="handleDragEnd(event)"
                             ondragover="handleDragOver(event)"
                             ondragenter="handleDragEnter(event, '${currentPath}')"
                             ondragleave="handleDragLeave(event)"
                             ondrop="handleDrop(event, '${currentPath}', 'folder')">
                            <span class="folder-arrow" onclick="toggleFolder('${currentPath}', event)">
                                ${hasChildren ? (isExpanded ? '▼' : '▶') : ''}
                            </span>
                            <span class="icon">📁</span>
                            <span>${name}</span>
                        </div>
                    `;
                    // Recursively render children only if expanded
                    if (hasChildren && isExpanded) {
                        html += renderTreeNodes(node.children, level + 1, currentPath);
                    }
                } else {
                    const icon = getFileIcon(name);
                    const filePath = node.path || currentPath;
                    const isActive = filePath === currentFile ? 'selected' : '';
                    html += `
                        <div class="tree-item file ${isActive}" 
                             data-path="${filePath}"
                             data-type="file"
                             style="padding-left: ${indent + 20}px" 
                             onclick="handleFileClick(event, '${filePath}')"
                             ondblclick="handleDoubleClick(event, '${filePath}', 'file')"
                             oncontextmenu="showContextMenu(event, '${filePath}', 'file')"
                             draggable="true"
                             ondragstart="handleDragStart(event, '${filePath}', 'file')"
                             ondragend="handleDragEnd(event)"
                             ondragover="handleDragOver(event)"
                             ondragenter="handleDragEnter(event, '${filePath}')"
                             ondragleave="handleDragLeave(event)"
                             ondrop="handleDrop(event, '${filePath}', 'file')">
                            <span class="icon">${icon}</span>
                            <span>${name}</span>
                        </div>
                    `;
                }
            });
            
            return html;
        }

        // Handle double click for rename
        function handleDoubleClick(event, path, type) {
            event.preventDefault();
            event.stopPropagation();
            
            clearTimeout(renameTimeout);
            renameTimeout = setTimeout(() => {
                enableInlineRename(event.currentTarget, path, type);
            }, 300);
        }

        // Separate single click handler for files
        function handleFileClick(event, filepath) {
            clearTimeout(renameTimeout);
            renameTimeout = setTimeout(() => {
                openFile(filepath);
            }, 250);
        }

        // Get file icon based on extension
        function getFileIcon(filename) {
            const ext = filename.split('.').pop().toLowerCase();
            const icons = {
                'js': '📄',
                'json': '📋',
                'html': '🌐',
                'css': '🎨',
                'md': '📝',
                'txt': '📃',
                'py': '🐍',
                'ts': '📘',
                'jsx': '⚛️',
                'tsx': '⚛️',
                'vue': '💚',
                'go': '🐹',
                'rs': '🦀',
                'java': '☕',
                'php': '🐘',
                'rb': '💎',
                'c': '🔷',
                'cpp': '🔷',
                'h': '🔷',
                'cs': '🟦',
                'swift': '🦉',
                'kt': '🟪'
            };
            return icons[ext] || '📄';
        }

        // Get language mode for file
        function getLanguageMode(filename) {
            const ext = filename.split('.').pop().toLowerCase();
            const languages = {
                'js': 'javascript',
                'json': 'json',
                'html': 'html',
                'css': 'css',
                'md': 'markdown',
                'py': 'python',
                'ts': 'typescript',
                'tsx': 'typescript',
                'jsx': 'javascript',
                'java': 'java',
                'go': 'go',
                'rs': 'rust',
                'php': 'php',
                'rb': 'ruby',
                'c': 'c',
                'cpp': 'cpp',
                'h': 'c',
                'cs': 'csharp',
                'swift': 'swift',
                'kt': 'kotlin',
                'sql': 'sql',
                'sh': 'shell',
                'yml': 'yaml',
                'yaml': 'yaml',
                'xml': 'xml'
            };
            return languages[ext] || 'plaintext';
        }

        // Select folder
        function selectFolder(folderPath, event) {
            if (event) {
                event.stopPropagation();
            }
            
            // If clicking the same folder, deselect it
            if (currentFolder === folderPath) {
                currentFolder = null;
            } else {
                currentFolder = folderPath;
            }
            
            updateTreeControlsHint();
            updateStatus(currentFolder ? `Selected folder: ${currentFolder}` : 'No folder selected');
            
            // Update visual selection
            document.querySelectorAll('.tree-item.folder').forEach(item => {
                item.classList.remove('selected');
            });
            
            if (currentFolder && event && event.currentTarget) {
                event.currentTarget.classList.add('selected');
            }
        }

        // Toggle folder
        function toggleFolder(folderPath, event) {
            event.stopPropagation();
            
            if (expandedFolders.has(folderPath)) {
                expandedFolders.delete(folderPath);
            } else {
                expandedFolders.add(folderPath);
            }
            
            loadProjectFiles();
        }

        // Update tree controls hint
        function updateTreeControlsHint() {
            const controls = document.getElementById('treeControls');
            if (controls) {
                if (currentFolder) {
                    controls.setAttribute('data-hint', `📁 ${currentFolder}`);
                } else {
                    controls.setAttribute('data-hint', '📁 root');
                }
            }
        }

        // Update file tree to show selected file
        function updateFileTree() {
            document.querySelectorAll('.tree-item.file').forEach(item => {
                item.classList.remove('selected');
            });
            
            // This is a bit hacky but works for now
            // In a real implementation, we'd store references to DOM elements
            loadProjectFiles();
        }

       // Show/hide modals
       function showNewProjectModal() {
           document.getElementById('newProjectModal').style.display = 'block';
           document.getElementById('newProjectName').focus();
       }

       function showNewFileModal() {
           if (!currentProject) {
               alert('Please select a project first');
               return;
           }
           
           const modal = document.getElementById('newFileModal');
           const input = document.getElementById('newFilePath');
           
           // Just show filename input, not the full path
           input.value = '';
           if (currentFolder) {
               input.placeholder = 'Enter filename (e.g., component.js)';
           } else {
               input.placeholder = 'Enter filename or path (e.g., index.js or src/index.js)';
           }
           
           modal.style.display = 'block';
           input.focus();
       }

       function showNewFolderModal() {
           if (!currentProject) {
               alert('Please select a project first');
               return;
           }
           
           const modal = document.getElementById('newFolderModal');
           const input = document.getElementById('newFolderPath');
           
           // Similar to file creation - just show folder name
           input.value = '';
           if (currentFolder) {
               input.placeholder = 'Enter folder name (e.g., components)';
           } else {
               input.placeholder = 'Enter folder name or path (e.g., src or src/components)';
           }
           
           modal.style.display = 'block';
           input.focus();
       }

       function closeModal(modalId) {
           document.getElementById(modalId).style.display = 'none';
       }

       // Create project
       async function createProject() {
           const name = document.getElementById('newProjectName').value.trim();
           const description = document.getElementById('newProjectDescription').value.trim();
           
           if (!name) {
               alert('Project name is required');
               return;
           }
           
           try {
               const response = await fetch(`${API_URL}/projects`, {
                   method: 'POST',
                   headers: { 'Content-Type': 'application/json' },
                   body: JSON.stringify({ name, description })
               });
               
               if (response.ok) {
                   const data = await response.json();
                   closeModal('newProjectModal');
                   await loadProjects();
                   document.getElementById('projectSelector').value = data.project.id;
                   loadProject(data.project.id);
                   updateStatus(`Created project: ${name}`);
               }
           } catch (error) {
               console.error('Error creating project:', error);
               updateStatus('Error creating project', true);
           }
       }

       // Create file
       async function createFile() {
           let filepath = document.getElementById('newFilePath').value.trim();
           
           if (!filepath) {
               alert('File name is required');
               return;
           }
           
           // If we have a current folder selected and the filepath doesn't contain /, prepend the folder
           if (currentFolder && !filepath.includes('/')) {
               filepath = currentFolder + '/' + filepath;
           }
           
           try {
               const language = getLanguageMode(filepath);
               const templates = {
                   'javascript': `// ${filepath}\n// Created on ${new Date().toLocaleString()}\n\n`,
                   'typescript': `// ${filepath}\n// Created on ${new Date().toLocaleString()}\n\n`,
                   'html': `<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>Document</title>\n</head>\n<body>\n    \n</body>\n</html>`,
                   'css': `/* ${filepath} */\n/* Created on ${new Date().toLocaleString()} */\n\n`,
                   'python': `# ${filepath}\n# Created on ${new Date().toLocaleString()}\n\n`,
                   'json': '{\n  \n}',
                   'markdown': `# ${filepath.split('/').pop().replace('.md', '')}\n\nCreated on ${new Date().toLocaleString()}\n\n`
               };
               
               const content = templates[language] || `// ${filepath}\n// Created on ${new Date().toLocaleString()}\n\n`;
               
               const response = await fetch(`${API_URL}/projects/${currentProject.id}/files`, {
                   method: 'POST',
                   headers: { 'Content-Type': 'application/json' },
                   body: JSON.stringify({ filepath, content })
               });
               
               if (response.ok) {
                   closeModal('newFileModal');
                   await loadProjectFiles();
                   openFile(filepath);
                   updateStatus(`Created file: ${filepath}`);
               }
           } catch (error) {
               console.error('Error creating file:', error);
               updateStatus('Error creating file', true);
           }
       }

       // Create folder
       async function createFolder() {
           let folderPath = document.getElementById('newFolderPath').value.trim();
           
           if (!folderPath) {
               alert('Folder name is required');
               return;
           }
           
           // If we have a current folder selected and the path doesn't contain /, prepend the folder
           if (currentFolder && !folderPath.includes('/')) {
               folderPath = currentFolder + '/' + folderPath;
           }
           
           console.log('Creating folder:', folderPath); // Debug log
           
           try {
               const response = await fetch(`${API_URL}/projects/${currentProject.id}/folders`, {
                   method: 'POST',
                   headers: { 'Content-Type': 'application/json' },
                   body: JSON.stringify({ folderPath })
               });
               
               const data = await response.json();
               
               if (response.ok) {
                   closeModal('newFolderModal');
                   
                   // Add the new folder to expanded folders so it shows open
                   expandedFolders.add(folderPath);
                   
                   await loadProjectFiles();
                   updateStatus(`Created folder: ${folderPath}`);
               } else {
                   alert(`Error: ${data.error}`);
               }
           } catch (error) {
               console.error('Error creating folder:', error);
               updateStatus('Error creating folder', true);
               alert(`Error creating folder: ${error.message}`);
           }
       }

       // Update status message
       function updateStatus(message, isError = false) {
           const statusMessage = document.getElementById('statusMessage');
           statusMessage.textContent = message;
           statusMessage.style.color = isError ? '#f48771' : '#ffffff';
           
           if (!isError) {
               setTimeout(() => {
                   statusMessage.textContent = 'Ready';
               }, 3000);
           }
       }

       // Drag and Drop Functions
       function handleDragStart(e, path, type) {
           draggedItem = e.target;
           draggedItemPath = path;
           draggedItemType = type;
           e.target.style.opacity = '0.5';
           e.dataTransfer.effectAllowed = 'move';
       }

       function handleDragEnd(e) {
           e.target.style.opacity = '';
           // Remove all drag-over classes
           document.querySelectorAll('.drag-over').forEach(el => {
               el.classList.remove('drag-over');
           });
       }

       function handleDragOver(e) {
           if (e.preventDefault) {
               e.preventDefault();
           }
           e.dataTransfer.dropEffect = 'move';
           return false;
       }

       function handleDragEnter(e, targetPath) {
           if (draggedItemPath === targetPath) return;
           e.currentTarget.classList.add('drag-over');
       }

       function handleDragLeave(e) {
           e.currentTarget.classList.remove('drag-over');
       }

       async function handleDrop(e, targetPath, targetType) {
           if (e.stopPropagation) {
               e.stopPropagation();
           }
           e.preventDefault();
           
           e.currentTarget.classList.remove('drag-over');
           
           // Don't drop on itself
           if (draggedItemPath === targetPath) return;
           
           // Don't drop a folder into its own child
           if (targetPath && draggedItemPath && targetPath.startsWith(draggedItemPath + '/')) {
               updateStatus('Cannot move a folder into itself', true);
               return;
           }
           
           // Determine the new path
           let newPath;
           if (targetType === 'root' || targetPath === '') {
               // Dropping in root
               const itemName = draggedItemPath.split('/').pop();
               newPath = itemName;
           } else if (targetType === 'folder') {
               // Dropping into a folder
               const itemName = draggedItemPath.split('/').pop();
               newPath = targetPath + '/' + itemName;
           } else {
               // Dropping next to a file (same directory)
               const targetDir = targetPath.substring(0, targetPath.lastIndexOf('/'));
               const itemName = draggedItemPath.split('/').pop();
               newPath = targetDir ? targetDir + '/' + itemName : itemName;
           }
           
           // Don't move if it's the same location
           if (draggedItemPath === newPath) return;
           
           // Move the item
           try {
               await moveItem(draggedItemPath, newPath, draggedItemType);
               updateStatus(`Moved ${draggedItemPath} to ${newPath || 'root'}`);
               await loadProjectFiles();
           } catch (error) {
               console.error('Error moving item:', error);
               updateStatus('Error moving item', true);
           }
           
           return false;
       }

       // Replace the moveItem function in project.html
        async function moveItem(oldPath, newPath, type) {
            console.log(`Moving ${type}: ${oldPath} -> ${newPath}`);
            
            if (type === 'file') {
                // Get file content
                const response = await fetch(`${API_URL}/projects/${currentProject.id}/files/${encodeURIComponent(oldPath)}`);
                const data = await response.json();
                
                // Create at new location
                await fetch(`${API_URL}/projects/${currentProject.id}/files`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ filepath: newPath, content: data.content })
                });
                
                // Delete from old location
                await fetch(`${API_URL}/projects/${currentProject.id}/files/${encodeURIComponent(oldPath)}`, {
                    method: 'DELETE'
                });
                
                // Update open files if needed
                if (openFiles.has(oldPath)) {
                    const content = openFiles.get(oldPath);
                    openFiles.delete(oldPath);
                    openFiles.set(newPath, content);
                    if (currentFile === oldPath) {
                        currentFile = newPath;
                    }
                }
            } else {
                // For folders, we need to:
                // 1. Move all files
                // 2. Delete the empty folder
                
                const response = await fetch(`${API_URL}/projects/${currentProject.id}/files`);
                const data = await response.json();
                
                // Find all files in this folder
                const filesToMove = data.files.filter(file => 
                    file.filepath.startsWith(oldPath + '/')
                );
                
                console.log(`Moving ${filesToMove.length} files from folder`);
                
                // Move each file
                for (const file of filesToMove) {
                    const relativePath = file.filepath.substring(oldPath.length);
                    const newFilePath = newPath + relativePath;
                    
                    const fileResponse = await fetch(`${API_URL}/projects/${currentProject.id}/files/${encodeURIComponent(file.filepath)}`);
                    const fileData = await fileResponse.json();
                    
                    await fetch(`${API_URL}/projects/${currentProject.id}/files`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ filepath: newFilePath, content: fileData.content })
                    });
                    
                    await fetch(`${API_URL}/projects/${currentProject.id}/files/${encodeURIComponent(file.filepath)}`, {
                        method: 'DELETE'
                    });
                }
                
                // Now delete the empty source folder
                console.log(`Deleting empty folder: ${oldPath}`);
                await fetch(`${API_URL}/projects/${currentProject.id}/folders/${encodeURIComponent(oldPath)}`, {
                    method: 'DELETE'
                });
            }
        }

        // Update showContextMenu to store the element
        function showContextMenu(event, path, type) {
            event.preventDefault();
            event.stopPropagation();
            
            contextMenuTarget = path;
            contextMenuType = type;
            
            // Store the element that was right-clicked
            window.lastContextElement = event.currentTarget;
            
            const menu = document.getElementById('contextMenu');
            menu.style.display = 'block';
            
            const x = event.pageX;
            const y = event.pageY;
            menu.style.left = x + 'px';
            menu.style.top = y + 'px';
            
            console.log('Context menu shown for:', path, type); // Debug
        }

        // Add this simple inline rename function
        function startInlineRename() {
            if (!contextMenuTarget || !window.lastContextElement) {
                console.log('No target for rename');
                return;
            }
            
            const element = window.lastContextElement;
            const nameSpan = element.querySelector('span:last-child');
            const originalName = contextMenuTarget.split('/').pop();
            
            console.log('Starting rename for:', originalName);
            
            // Create input
            const input = document.createElement('input');
            input.type = 'text';
            input.value = originalName;
            input.style.cssText = 'background: #3c3c3c; border: 1px solid #007acc; color: #fff; padding: 2px;';
            
            // Replace text with input
            nameSpan.textContent = '';
            nameSpan.appendChild(input);
            input.focus();
            input.select();
            
            // Save on Enter
            input.addEventListener('keydown', async (e) => {
                if (e.key === 'Enter') {
                    const newName = input.value.trim();
                    if (newName && newName !== originalName) {
                        await performRename(contextMenuTarget, newName, contextMenuType);
                    }
                    nameSpan.textContent = originalName;
                } else if (e.key === 'Escape') {
                    nameSpan.textContent = originalName;
                }
            });
            
            // Save on blur
            input.addEventListener('blur', () => {
                setTimeout(() => {
                    nameSpan.textContent = originalName;
                }, 200);
            });
        }

        // Update performRename in project.html
        async function performRename(oldPath, newName, type) {
            const basePath = oldPath.substring(0, oldPath.lastIndexOf('/'));
            const newPath = basePath ? basePath + '/' + newName : newName;
            
            console.log('Renaming:', oldPath, 'to', newPath, 'Type:', type);
            
            try {
                const response = await fetch(`${API_URL}/projects/${currentProject.id}/rename`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        oldPath: oldPath, 
                        newPath: newPath, 
                        isFolder: type === 'folder' 
                    })
                });
                
                const result = await response.json();
                
                if (response.ok && result.success) {
                    updateStatus(`Renamed to ${newName}`);
                    
                    // Update open files if it was a file
                    if (type === 'file' && openFiles.has(oldPath)) {
                        const content = openFiles.get(oldPath);
                        openFiles.delete(oldPath);
                        openFiles.set(newPath, content);
                        if (currentFile === oldPath) {
                            currentFile = newPath;
                            updateTabs();
                        }
                    }
                    
                    // Update folder references if it was a folder
                    if (type === 'folder') {
                        // Update expanded folders
                        if (expandedFolders.has(oldPath)) {
                            expandedFolders.delete(oldPath);
                            expandedFolders.add(newPath);
                        }
                        
                        // Update current folder if needed
                        if (currentFolder === oldPath) {
                            currentFolder = newPath;
                            updateTreeControlsHint();
                        }
                        
                        // Update any open files that were in this folder
                        const filesToUpdate = [];
                        openFiles.forEach((content, filepath) => {
                            if (filepath.startsWith(oldPath + '/')) {
                                filesToUpdate.push({ oldPath: filepath, newPath: filepath.replace(oldPath, newPath), content });
                            }
                        });
                        
                        filesToUpdate.forEach(({ oldPath, newPath, content }) => {
                            openFiles.delete(oldPath);
                            openFiles.set(newPath, content);
                            if (currentFile === oldPath) {
                                currentFile = newPath;
                            }
                        });
                        
                        if (filesToUpdate.length > 0) {
                            updateTabs();
                        }
                    }
                    
                    await loadProjectFiles();
                } else {
                    console.error('Rename failed:', result);
                    updateStatus('Rename failed: ' + (result.error || 'Unknown error'), true);
                }
            } catch (error) {
                console.error('Error renaming:', error);
                updateStatus('Error renaming: ' + error.message, true);
            }
        }

        // Rename item
        async function renameItem() {
            if (!contextMenuTarget) return;
            
            const oldName = contextMenuTarget.split('/').pop();
            const newName = prompt(`Rename ${contextMenuType}:`, oldName);
            
            if (!newName || newName === oldName) return;
            
            const basePath = contextMenuTarget.substring(0, contextMenuTarget.lastIndexOf('/'));
            const newPath = basePath ? basePath + '/' + newName : newName;
            
            try {
                await moveItem(contextMenuTarget, newPath, contextMenuType);
                updateStatus(`Renamed ${oldName} to ${newName}`);
                await loadProjectFiles();
            } catch (error) {
                console.error('Error renaming:', error);
                updateStatus('Error renaming item', true);
            }
        }

        // Update deleteItem with better undo support
        async function deleteItem() {
            if (!contextMenuTarget) return;
            
            const name = contextMenuTarget.split('/').pop();
            
            try {
                if (contextMenuType === 'file') {
                    // Store file content before deleting
                    const response = await fetch(`${API_URL}/projects/${currentProject.id}/files/${encodeURIComponent(contextMenuTarget)}`);
                    if (!response.ok) {
                        throw new Error('Failed to get file for backup');
                    }
                    
                    const fileData = await response.json();
                    const savedContent = fileData.content;
                    const savedPath = contextMenuTarget;
                    
                    // Delete the file
                    const deleteResponse = await fetch(`${API_URL}/projects/${currentProject.id}/files/${encodeURIComponent(contextMenuTarget)}`, {
                        method: 'DELETE'
                    });
                    
                    if (!deleteResponse.ok) {
                        throw new Error('Failed to delete file');
                    }
                    
                    if (openFiles.has(contextMenuTarget)) {
                        closeFile(contextMenuTarget);
                    }
                    
                    // Show undo notification with restore function
                    showUndoNotification(name, 'file', async () => {
                        // Restore the file
                        const restoreResponse = await fetch(`${API_URL}/projects/${currentProject.id}/files`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ 
                                filepath: savedPath, 
                                content: savedContent 
                            })
                        });
                        
                        if (!restoreResponse.ok) {
                            throw new Error('Failed to restore file');
                        }
                        
                        await loadProjectFiles();
                        updateStatus(`Restored file: ${name}`);
                    });
                    
                    updateStatus(`Deleted file: ${name}`);
                    
                } else {
                    // For folders, store the folder structure before deleting
                    const filesResponse = await fetch(`${API_URL}/projects/${currentProject.id}/files`);
                    const filesData = await filesResponse.json();
                    
                    // Find all files in the folder
                    const folderFiles = filesData.files.filter(file => 
                        file.filepath === contextMenuTarget || 
                        file.filepath.startsWith(contextMenuTarget + '/')
                    );
                    
                    // Store file contents before deletion
                    const savedFiles = [];
                    for (const file of folderFiles) {
                        const fileResponse = await fetch(`${API_URL}/projects/${currentProject.id}/files/${encodeURIComponent(file.filepath)}`);
                        if (fileResponse.ok) {
                            const fileData = await fileResponse.json();
                            savedFiles.push({
                                filepath: file.filepath,
                                content: fileData.content
                            });
                        }
                    }
                    
                    // Delete the folder
                    const deleteResponse = await fetch(
                        `${API_URL}/projects/${currentProject.id}/folders/${encodeURIComponent(contextMenuTarget)}`, 
                        {
                            method: 'DELETE'
                        }
                    );
                    
                    if (!deleteResponse.ok) {
                        throw new Error('Failed to delete folder');
                    }
                    
                    // Update UI
                    if (currentFolder === contextMenuTarget) {
                        currentFolder = null;
                        updateTreeControlsHint();
                    }
                    expandedFolders.delete(contextMenuTarget);
                    
                    // Close any open files from this folder
                    savedFiles.forEach(file => {
                        if (openFiles.has(file.filepath)) {
                            closeFile(file.filepath);
                        }
                    });
                    
                    // Show undo notification with restore function
                    const folderPath = contextMenuTarget;
                    showUndoNotification(name, 'folder', async () => {
                        // First recreate the folder
                        const folderResponse = await fetch(`${API_URL}/projects/${currentProject.id}/folders`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ folderPath })
                        });
                        
                        if (!folderResponse.ok) {
                            throw new Error('Failed to restore folder');
                        }
                        
                        // Then restore all files
                        for (const file of savedFiles) {
                            await fetch(`${API_URL}/projects/${currentProject.id}/files`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ 
                                    filepath: file.filepath, 
                                    content: file.content 
                                })
                            });
                        }
                        
                        await loadProjectFiles();
                        updateStatus(`Restored folder: ${name} (${savedFiles.length} files)`);
                    });
                    
                    updateStatus(`Deleted folder: ${name}`);
                }
                
                await loadProjectFiles();
                
            } catch (error) {
                console.error('Error deleting:', error);
                updateStatus(`Error deleting: ${error.message}`, true);
            }
        }

       // New file in specific folder
       function newFileInFolder() {
           if (contextMenuType === 'folder') {
               currentFolder = contextMenuTarget;
               updateTreeControlsHint();
               showNewFileModal();
           }
       }

       // New folder in specific folder  
       function newFolderInFolder() {
           if (contextMenuType === 'folder') {
               currentFolder = contextMenuTarget;
               updateTreeControlsHint();
               showNewFolderModal();
           }
       }
    </script>
</body>
</html>